<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brute Force String Matching - Home</title>
    <link rel="stylesheet" href="intro_styles.css">
    <link rel="stylesheet" href="sidebar.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css"/>
</head>
<body>

    <!-- Sidebar (Always Visible) -->
    <div class="sidebar">
        <header>Menu</header>
        <ul>
            <li><a href="index.html"><i class="fas fa-home"></i> Introduction</a></li>
            <li><a href="algo_index.html"><i class="fas fa-code"></i> Algorithm</a></li>
            <li><a href="sim_index.html"><i class="fas fa-play"></i> Simulation</a></li>
            <li><a href="code_index.html"><i class="fas fa-code"></i> Code</a></li>

        </ul>
    </div>

    <main>
        <h1>Brute Force String Matching</h1>
        
        <br>
        <section>
            <h2>Introduction</h2>
            
            <p>Brute Force (also known as Naïve String Matching) is the simplest method for finding a pattern in a given text. It works by checking for a match at every possible position in the text, one character at a time.</p>
        </section>

        <section>
            <h2>How It Works</h2>
            
            <p><i><b>The algorithm follows these steps:</b></i></p>
            <ol>
                <li>1. Start from the first character of the text.</li>
                <li>2. Compare it with the first character of the pattern.</li>
                <li>3. If they match, continue checking the next characters until the full pattern is matched.</li>
                <li>4. If a mismatch occurs, shift the pattern one position to the right and repeat.</li>
                <li>5. Continue until the pattern is found or the text ends.</li>
            </ol>
        </section>

        <section>
    <h2>Algorithm Complexity</h2>

    <ul>
        <li>
            <strong>Best Case: O(n)</strong> – Happens when mismatches occur early, allowing quick shifts.  
            <pre>
    Text:    A B C D E F G H I J
    Pattern: X Y Z
            </pre>
            The pattern immediately fails at the first character, leading to at most <strong>n</strong> comparisons.
        </li>
        <li>
            <strong>Worst Case: O(m × n)</strong> – Occurs when the pattern closely matches the text but fails at the last character.  
            <pre>
    Text:    A A A A A A A A A B
    Pattern: A A A A A
            </pre>
            The algorithm rechecks many positions, leading to <strong>m × n</strong> comparisons.
        </li>
    </ul>
</section>

        
        

        <section>
            <h2>Real-Time Application</h2>
            
            <p><i>Brute force string matching is widely used in various fields. One practical example is in cybersecurity:</i></p>
            <p><strong>Plagiarism Detection:</strong> Many tools scan documents by searching for exact text matches within a database of existing content. The brute force algorithm helps compare character sequences and find instances of copied material.</p>
            <p><strong>Other Real-World Applications:</strong></p>
            <ul>
                <li>DNA Sequence Matching in Bioinformatics</li>
                <li>Text Searching in Search Engines</li>
                <li>Spam Filtering in Emails</li>
                <li>Intrusion Detection in Cybersecurity</li>
            </ul>
        </section>
        
        

        <section>
            <h2>Conclusion</h2>
            
            <p>The brute force string matching algorithm is simple to understand and implement, but it can become inefficient for large texts or patterns. Nevertheless, it remains a foundational algorithm for learning pattern matching concepts!</p>
        </section>
    </main>

</body>
</html>
